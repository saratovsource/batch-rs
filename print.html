<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Batch Guide</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="User guide for the batch-rs library.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="batch.html">Batch</a></li><li><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><a href="tasks.html"><strong aria-hidden="true">3.</strong> Tasks</a></li><li><a href="queries.html"><strong aria-hidden="true">4.</strong> Queries</a></li><li><a href="worker.html"><strong aria-hidden="true">5.</strong> Worker</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Batch Guide</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#batch" id="batch"><h1>Batch</h1></a>
<p>A distributed task queue library written in Rust using RabbitMQ as a message
broker.</p>
<p>This library allows you to send a task to a RabbitMQ broker, so that a worker
will be able to pull it and execute the associated handler. It leverages the
<code>futures</code> and <code>tokio-core</code> crates to provide asynchronous I/O operations.</p>
<a class="header" href="print.html#goals" id="goals"><h2>Goals</h2></a>
<ul>
<li><strong>Safe</strong>: favor safety when possible, minimising risks and mistakes.</li>
<li><strong>Extensible</strong>: enable developers to easily add new behaviour to the Query
system.</li>
<li><strong>Smart</strong>: allow developers to save time by making the easy obvious, and by
providing sensible defaults.</li>
</ul>
<a class="header" href="print.html#non-goals" id="non-goals"><h2>Non Goals</h2></a>
<ul>
<li>Multiple broker adapters: for the forseeable future RabbitMQ/AMQP will be the
only officially supported message broker</li>
</ul>
<a class="header" href="print.html#installation" id="installation"><h1>Installation</h1></a>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
batch = &quot;0.1&quot;
</code></pre>
<blockquote>
<p><strong>Note</strong>: Task serialization depends on <a href="https://serde.rs"><code>serde</code></a>, so you will have to add it
to your project's dependencies as well.</p>
</blockquote>
<p>Then add this to your crate root:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate batch;
#}</code></pre></pre>
<p>Examples are available on <a href="https://github.com/kureuil/batch-rs/tree/master/batch/examples">GitHub</a> or you can continue and read the
Getting Started guide.</p>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting started</h1></a>
<p>The first thing you'll want to do once you've installed <code>batch</code> is connect to a
RabbitMQ broker. We'll start by creating a <code>Client</code>:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate batch;
extern crate tokio_core;

use batch::ClientBuilder;
use tokio_core::reactor::Core;

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let client = ClientBuilder::new()
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .handle(handle)
        .build();

    core.run(client).unwrap();
}
</code></pre></pre>
<p>Now, that we're connected to our broker, we'll create our first task. A task is
a work of unit that you want to asynchronously, becuse handling synchronously is
not possible or wouldn't be ideal (e.g sending a mail from a web API). The
easiest of creating a task, is by declaring a structure, and derive <code>Task</code> on
it:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::ClientBuilder;
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let client = ClientBuilder::new()
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .handle(handle)
        .build();

    core.run(client).unwrap();
}
</code></pre></pre>
<blockquote>
<p><strong>Note</strong>: you can see that in addition to <code>Task</code>, we're also deriving
<code>serde</code>'s <code>Serialize</code> &amp; <code>Deserialize</code> traits. This is necessary in order to
safely send task over the network.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong>: When deriving <code>Task</code> we added the (mandatory) <code>task_routing_key</code>
attribute, it is used by RabbitMQ to deliver your message to the right worker.</p>
</blockquote>
<p>Now that we have our task, we can send it to our message broker:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate futures;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::{job, ClientBuilder};
use futures::Future;
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let client = ClientBuilder::new()
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .handle(handle)
        .build();

    let send = client.and_then(|client| {
        let task = SayHello {
            to: &quot;Ferris&quot;.into()
        };

        job(task).send(&amp;client)
    });

    core.run(send).unwrap();
}
</code></pre></pre>
<p>Now that our task has been published to our broker, we'll need to fetch it and
assign a function to this task. To do this, we'll create a new program, the
<em>worker</em>:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::{queue, WorkerBuilder};
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let queues = vec![queue(&quot;hello-world&quot;)];
    let worker = WorkerBuilder::new(())
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .queues(queues)
        .handle(handle)
        .build()
        .unwrap();

    core.run(worker.run()).unwrap();
}
</code></pre></pre>
<p>In order to register our task on the worker, we'll need to make it executable by
implementing the <code>Perform</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;
extern crate tokio_core;

use batch::{queue, Perform, WorkerBuilder};
use tokio_core::reactor::Core;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;hello-world&quot;]
struct SayHello {
    to: String,
}

impl Perform for SayHello {
    type Context = ();

    fn perform(&amp;self, _ctx: Self::Context) {
        println!(&quot;Hello {}!&quot;, self.to);
    }
}

fn main() {
    let mut core = Core::new().unwrap();
    let handle = core.handle();

    let queues = vec![queue(&quot;hello-world&quot;)];
    let worker = WorkerBuilder::new(())
        .connection_url(&quot;amqp://localhost/%2f&quot;)
        .queues(queues)
        .handle(handle)
        .task::&lt;SayHello&gt;()
        .build()
        .unwrap();

    core.run(worker.run()).unwrap();
}
</code></pre></pre>
<p>We can now run our <em>worker</em> program and see the <code>Hello Ferris!</code> message
displayed in the terminal.</p>
<a class="header" href="print.html#tasks" id="tasks"><h1>Tasks</h1></a>
<p>A task is a unit of work which computation can be deferred using <code>batch</code>. You
declare a task by implementing the <code>Task</code> trait on a structure. Note that
implementing this trait requires you to also implement <a href="https://serde.rs"><code>serde</code></a>'s <code>Serialize</code>
and <code>Deserialize</code> traits, this is required in order to safely send your tasks
between processes.</p>
<p>The <code>Task</code> trait allows you to specify a default configuration for your task
(e.g: default timeout, default number of retries). Usually you will use
<code>batch</code>'s procedural macros and derive the trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate batch;
extern crate serde;
#[macro_use]
extern crate serde_derive;

#[derive(Serialize, Deserialize, Task)]
#[task_routing_key = &quot;messaging&quot;]
struct SayHello {
    to: String,
}
#}</code></pre></pre>
<a class="header" href="print.html#task_routing_key-attribute" id="task_routing_key-attribute"><h2><code>task_routing_key</code> attribute</h2></a>
<p>The only mandatory attribute is <code>task_routing_key</code>, which is used to transfer a
task from an <em>exchange</em> (where the <code>Client</code> publishes) to a <em>queue</em> (where the
<code>Worker</code> consumes messages from).</p>
<a class="header" href="print.html#task_name-attribute" id="task_name-attribute"><h2><code>task_name</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: The name of the type deriving <code>Task</code></p>
</blockquote>
<p>This value is used to register and identify tasks in the worker, mapping a
<code>task_name</code> to a deserializer. This attribute should be unique in your project.</p>
<a class="header" href="print.html#task_exchange-attribute" id="task_exchange-attribute"><h2><code>task_exchange</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: empty string (default RabbitMQ exchange)</p>
</blockquote>
<p>This value is used when publishing a task to RabbitMQ. If you set a custom
exchange name, you must ensure that it is declared before using it (see
<a href="https://docs.rs/batch/0.1/batch/struct.ClientBuilder.html#method.exchanges"><code>ClientBuilder::exchanges</code></a>).</p>
<a class="header" href="print.html#task_timeout-attribute" id="task_timeout-attribute"><h2><code>task_timeout</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: 900 seconds (15 minutes)</p>
</blockquote>
<p>This attribute gives the number of seconds allowed before a task execution is
considered failed. If the execution of a task takes longer that the given
timeout, it is stopped, marked as failed and if needed tried again.</p>
<a class="header" href="print.html#task_retries-attribute" id="task_retries-attribute"><h2><code>task_retries</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: 2</p>
</blockquote>
<p>This attribute gives the number of times a task should be tried again in case of
failure. When a task is retried, it is pushed as a new task would be with the
exact same attributes except for the <code>task_retries</code> attribute that gets
decremented.</p>
<a class="header" href="print.html#task_priority-attribute" id="task_priority-attribute"><h2><code>task_priority</code> attribute</h2></a>
<blockquote>
<p><strong>Default value</strong>: <a href="https://docs.rs/batch/0.1/batch/enum.Priority.html"><code>Priority::Normal</code></a></p>
</blockquote>
<p>This attribute is used to mark some jobs as more or less important than other
and prioritize them for the consumer.</p>
<a class="header" href="print.html#queries" id="queries"><h1>Queries</h1></a>
<p>Queries are the API used when publishing a task to the message broker. A <code>Query</code>
allows you to overwrite any defaults provided by the <code>Task</code> trait and allows you
to call any extension registered. A <code>Query</code> is manipulated in the same way as a
builder: it exposes a fluent interface where you chain method calls, before
calling the final method <code>send</code>.</p>
<p>You create a query by calling the <code>job</code> function, giving it a <code>Task</code> instance as
parameter, and you send it by calling the <code>send</code> method, giving it a reference
to your <code>Client</code> instance:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let client = /* your batch Client instance */;
let task = /* your batch Task instance */;
job(task).send(&amp;client);
#}</code></pre></pre>
<p>See <a href="https://docs.rs/batch/0.1/batch/struct.Query.html"><code>Query</code> API documentation</a>.</p>
<a class="header" href="print.html#extending-query" id="extending-query"><h2>Extending <code>Query</code></h2></a>
<p>By defining an <a href="https://github.com/rust-lang/rfcs/blob/master/text/0445-extension-trait-conventions.md">extension trait</a>, you can add new methods to the <a href="https://docs.rs/batch/0.1/batch/struct.Query.html"><code>Query</code></a> type.
In order to make them useful, <code>batch</code> provides several methods that are meant to
be called from your extension traits:</p>
<ul>
<li><a href="https://docs.rs/batch/0.1/batch/struct.Query.html#method.properties"><code>properties</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.Query.html#method.properties_mut"><code>properties_mut</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.Query.html#method.options"><code>options</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.Query.html#method.options_mut"><code>options_mut</code></a></li>
</ul>
<a class="header" href="print.html#extending-exchangebuilder" id="extending-exchangebuilder"><h2>Extending <code>ExchangeBuilder</code></h2></a>
<p>By defining an <a href="https://github.com/rust-lang/rfcs/blob/master/text/0445-extension-trait-conventions.md">extension trait</a>, you can add new methods to the
<a href="https://docs.rs/batch/0.1/batch/struct.ExchangeBuilder.html"><code>ExchangeBuilder</code></a> type. In order to make them useful, <code>batch</code> provides several
methods that are meant to be called from your extension traits:</p>
<ul>
<li><a href="https://docs.rs/batch/0.1/batch/struct.ExchangeBuilder.html#method.options"><code>options</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.ExchangeBuilder.html#method.options_mut"><code>options_mut</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.ExchangeBuilder.html#method.arguments"><code>arguments</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.ExchangeBuilder.html#method.arguments_mut"><code>arguments_mut</code></a></li>
</ul>
<a class="header" href="print.html#extending-queue" id="extending-queue"><h2>Extending <code>Queue</code></h2></a>
<p>By defining an <a href="https://github.com/rust-lang/rfcs/blob/master/text/0445-extension-trait-conventions.md">extension trait</a>, you can add new methods to the
<a href="https://docs.rs/batch/0.1/batch/struct.QueueBuilder.html"><code>QueueBuilder</code></a> type. In order to make them useful, <code>batch</code> provides several
methods that are meant to be called from your extension traits:</p>
<ul>
<li><a href="https://docs.rs/batch/0.1/batch/struct.QueueBuilder.html#method.options"><code>options</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.QueueBuilder.html#method.options_mut"><code>options_mut</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.QueueBuilder.html#method.arguments"><code>arguments</code></a></li>
<li><a href="https://docs.rs/batch/0.1/batch/struct.QueueBuilder.html#method.arguments_mut"><code>arguments_mut</code></a></li>
</ul>
<a class="header" href="print.html#worker" id="worker"><h1>Worker</h1></a>
<p>The <code>Worker</code> is the most delicate piece of code of the project because of the
choices and trade-offs that have been made. It is a piece software that is
designed to be always running, spawning new tasks as needed &amp; never crashing.</p>
<p>Just like the resque worker, it assumes chaos: each task is executed in its own
process allowing for maximum isolation between tasks and minimum risks of shared
corruption crash. It also enables features such as timeouts that would be
downright impossible to implement with threads for example.</p>
<p>In order to have one process per task, the <code>Worker</code> executes itself (the current
executable file) with a special environment variable signaling that it should
read a task payload on the standard input instead of pulling new tasks from the
message broker. This means that it might be complicated to integrate the
<code>Worker</code> into an existing binary: the recommended way of using the <code>Worker</code> is
by creating a dedicated binary which only goal is pulling tasks &amp; spawning
processes.</p>
<p>By default, the <code>Worker</code> will process as many tasks in parallel as there are
logical cores on the system. You can tweak this number when creating a
<code>Worker</code> using the <a href="https://docs.rs/batch/0.1/batch/struct.WorkerBuilder.html#method.parallelism"><code>WorkerBuilder::parallelism</code></a> method.</p>
<p>See <a href="https://docs.rs/batch/0.1/batch/struct.Worker.html"><code>Worker</code> API documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
